# -*- coding: utf-8 -*-
"""Complete Streamlit App

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1UhQbwZO_lRvd0ZDq9UsPsJhBrYlm3tTq
"""

# Commented out IPython magic to ensure Python compatibility.
# %pip install streamlit

# -*- coding: utf-8 -*-
# app.py

# First, import the necessary libraries.
# streamlit is used for creating the web application interface.
# joblib is for loading the pre-trained model file.
# numpy is for handling numerical data and arrays.
import streamlit as st
import joblib
import numpy as np
import pandas as pd
import tensorflow as tf
from tensorflow import keras

# A best practice for Streamlit: use st.cache_resource to load the model only once.
# This prevents the model from being reloaded every time the user interacts with the app,
# making the app much faster and more efficient.
@st.cache_resource
def load_model():
    """
    Loads the pre-trained model from the 'model.pkl' file.
    Includes error handling to inform the user if the model file is not found.
    """
    try:
        model = joblib.load('model.pkl')
        st.success("Model loaded successfully!")
        return model
    except Exception as e:
        st.error(f"Error loading model: {e}")
        st.warning("Please ensure 'model.pkl' is in the same directory.")
        return None

# Load the model at the start of the app execution.
model = load_model()

# Set up the main title and a brief description for the app's user interface.
st.title("CO2 Emissions Prediction ðŸš—")
st.markdown("Enter the vehicle's specifications to predict its CO2 emissions.")

# Create a dedicated section with a header for user input.
st.header("Vehicle Specifications")

# Create input fields for each feature the model expects.
# The order and data types of these inputs must match the data used for training the model.
# Using st.number_input is ideal for numerical data.
# The value parameter sets the default value shown in the input box.
engine_size = st.number_input("Engine Size (L)", min_value=0.0, max_value=20.0, value=2.0)
cylinders = st.number_input("Cylinders", min_value=1, max_value=16, value=4)
fuel_consumption_city = st.number_input("Fuel Consumption City (L/100 km)", min_value=0.0, max_value=50.0, value=10.0)
fuel_consumption_hwy = st.number_input("Fuel Consumption Hwy (L/100 km)", min_value=0.0, max_value=50.0, value=7.0)
fuel_consumption_comb = st.number_input("Fuel Consumption Combined (L/100 km)", min_value=0.0, max_value=50.0, value=8.5)
fuel_consumption_comb_mpg = st.number_input("Fuel Consumption Combined (MPG)", min_value=0.0, max_value=100.0, value=30.0)

# Create a button that, when clicked, will trigger the prediction.
if st.button("Predict CO2 Emissions"):
    # Check if the model has been loaded successfully before making a prediction.
    if model is not None:
        try:
            # Prepare the user's input data into a format the model can use.
            # This must be a NumPy array with the same number of features as the training data.
            # The order of the features is crucial!
            input_data = np.array([[engine_size, cylinders, fuel_consumption_city,
                                    fuel_consumption_hwy, fuel_consumption_comb,
                                    fuel_consumption_comb_mpg]])

            # Use the loaded model to make a prediction on the input data.
            prediction = model.predict(input_data)

            # Display the prediction result to the user in a clear and friendly way.
            st.subheader("Prediction Result:")
            st.success(f"The predicted CO2 emissions are: {prediction[0][0]:.2f} g/km")

        except Exception as e:
            # Catch any errors that might happen during the prediction process and display them.
            st.error(f"Prediction failed: {e}")
    else:
        st.warning("Model is not loaded. Please fix the previous error and refresh the page.")

